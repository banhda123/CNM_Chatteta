import { Server } from "socket.io";
import {
  createConversation,
  joinConversation,
  saveMessage,
  seenMessage,
  updateLastMesssage,
} from "../controllers/chatController.js";
import {
  acceptFriend,
  addFriend,
  deleteRequestFriend,
  DontAcceptFriend,
  unFriend,
} from "../controllers/UserController.js";
import { MessageModel } from "../models/MessageModel.js";
import { ConversationModel } from "../models/ConversationModel.js";

// Bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ io instance ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng t·ª´ c√°c module kh√°c
let ioInstance = null;

export const ConnectSocket = (server) => {
  const io = new Server(server, {
    cors: {
      origin: ["http://localhost:3000", "http://localhost", "http://localhost:8081"],
      methods: ["GET", "POST", "PUT", "DELETE", "PATCH"],
      allowedHeaders: ["my-custom-header", "Content-Type", "Authorization"],
      credentials: true,
    },
  });
  
  // L∆∞u io instance ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng t·ª´ b√™n ngo√†i
  ioInstance = io;

  io.on("connection", (socket) => {
    console.log(`${socket.id} connected`);

    socket.on("join_room", (User) => {
      console.log("join-room");
      socket.join(User._id);
    });

    socket.on("leave_room", (User) => {
      console.log("leave-room");
      socket.leave(User._id);
    });

    socket.on("add_friend", async (data) => {
      const { userFrom, userTo } = data;
      await addFriend(userFrom, userTo);

      io.emit("add_friend_success");
      io.to(userTo).emit("new_request_friend", userTo);
    });

    socket.on("delete_request_friend", async (data) => {
      const { userFrom, userTo } = data;
      await deleteRequestFriend(userFrom, userTo);
      io.emit("delete_request_friend_success");
      io.to(userTo).emit("person_delete_request_friend", userTo);
    });

    socket.on("accept_request_friend", async (data) => {
      const { userFrom, userTo } = data;
      await acceptFriend(userFrom, userTo);

      io.emit("accept_request_friend_success", userFrom);
      io.to(userTo).emit("accept_request_friend", userTo);
    });

    socket.on("dont_accept_request_friend", async (data) => {
      const { userFrom, userTo } = data;
      await DontAcceptFriend(userFrom, userTo);

      io.emit("dont_accept_request_friend_success", userFrom);
      io.to(userTo).emit("dont_accept_request_friend", userTo);
    });

    socket.on("un_friend", async (data) => {
      const { userFrom, userTo, idConversation } = data;
      await unFriend(userFrom, userTo, idConversation);

      io.emit("un_friend_success", userFrom);
      io.to(userTo).emit("un_friend", userTo);
    });

    socket.on("join_conversation", (idConversation) => {
      socket.join(idConversation);
    });

    socket.on("join_all_conversation", (array) => {
      socket.join(array);
    });

    socket.on("seen_message", async (idConversation) => {
      await seenMessage(idConversation);
      io.to(idConversation).emit("seen_message");
    });

    socket.on("send_message", async (data) => {
      try {
        const newMessage = await saveMessage(data);
        
        // Ki·ªÉm tra n·∫øu tin nh·∫Øn kh√¥ng ƒë∆∞·ª£c l∆∞u th√†nh c√¥ng
        if (!newMessage) {
          console.error("Failed to save message");
          return;
        }
        
        await updateLastMesssage({
          idConversation: newMessage.idConversation,
          message: newMessage._id,
        });

        // Emit to the conversation room for real-time chat updates
        io.to(newMessage.idConversation.toString()).emit(
          "new_message",
          newMessage
        );
        
        // Ghi log th√™m th√¥ng tin v·ªÅ lo·∫°i tin nh·∫Øn ƒë√£ g·ª≠i
        console.log(`üì® Tin nh·∫Øn m·ªõi ƒë√£ ƒë∆∞·ª£c g·ª≠i - ID: ${newMessage._id}, Lo·∫°i: ${newMessage.type}`);
        
        // Get the updated conversation with populated data
        const conversation = await ConversationModel.findById(newMessage.idConversation)
          .populate({
            path: "members.idUser",
            select: { name: 1, avatar: 1 }
          })
          .populate("lastMessage");
          
        if (conversation && conversation.members) {
          console.log(`üì£ C·∫≠p nh·∫≠t danh s√°ch cu·ªôc tr√≤ chuy·ªán cho ${conversation.members.length} th√†nh vi√™n`);
          
          // Emit update_conversation_list to each member to move the conversation to the top
          conversation.members.forEach(member => {
            if (member.idUser && member.idUser._id) {
              console.log(`üë§ G·ª≠i c·∫≠p nh·∫≠t cho user: ${member.idUser._id}`);
              io.to(member.idUser._id.toString()).emit("update_conversation_list", {
                conversation: conversation,
                newMessage: newMessage
              });
            }
          });
        }
      } catch (error) {
        console.error("Error handling send_message:", error);
      }
    });

    socket.on("revoke_message", async (data) => {
      try {
        const { messageId, conversationId, userId } = data;
        
        // T√¨m tin nh·∫Øn
        const message = await MessageModel.findById(messageId);
        
        if (!message) {
          socket.emit("revoke_message_error", { error: "Kh√¥ng t√¨m th·∫•y tin nh·∫Øn" });
          return;
        }
        
        // Ki·ªÉm tra ng∆∞·ªùi thu h·ªìi tin nh·∫Øn c√≥ ph·∫£i l√† ng∆∞·ªùi g·ª≠i kh√¥ng
        if (message.sender.toString() !== userId) {
          socket.emit("revoke_message_error", { error: "B·∫°n ch·ªâ c√≥ th·ªÉ thu h·ªìi tin nh·∫Øn c·ªßa ch√≠nh m√¨nh" });
          return;
        }
        
        // L∆∞u th√¥ng tin lo·∫°i tin nh·∫Øn tr∆∞·ªõc khi c·∫≠p nh·∫≠t
        const messageType = message.type || 'text';
        const hasFile = !!message.fileUrl;
        console.log(`üìù Thu h·ªìi tin nh·∫Øn ID ${messageId}, lo·∫°i: ${messageType}, c√≥ file: ${hasFile}`);
        
        // C·∫≠p nh·∫≠t t√¨nh tr·∫°ng thu h·ªìi tin nh·∫Øn
        message.isRevoked = true;
        await message.save();
        
        // Th√¥ng b√°o cho t·∫•t c·∫£ ng∆∞·ªùi d√πng trong cu·ªôc tr√≤ chuy·ªán
        io.to(conversationId).emit("message_revoked", { 
          messageId, 
          conversationId,
          type: messageType, // G·ª≠i ƒë√∫ng lo·∫°i tin nh·∫Øn cho client
          hasFile: hasFile // Th√™m th√¥ng tin c√≥ ph·∫£i l√† file hay kh√¥ng
        });
      } catch (error) {
        console.error("Error revoking message via socket:", error);
        socket.emit("revoke_message_error", { error: "Kh√¥ng th·ªÉ thu h·ªìi tin nh·∫Øn" });
      }
    });
    
    socket.on("delete_message", async (data) => {
      try {
        const { messageId, conversationId, userId } = data;
        
        // T√¨m tin nh·∫Øn
        const message = await MessageModel.findById(messageId);
        
        if (!message) {
          socket.emit("delete_message_error", { error: "Kh√¥ng t√¨m th·∫•y tin nh·∫Øn" });
          return;
        }
        
        // Kh√¥ng c·∫ßn ki·ªÉm tra ng∆∞·ªùi x√≥a c√≥ ph·∫£i ng∆∞·ªùi g·ª≠i kh√¥ng
        // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ x√≥a tin nh·∫Øn n√†y ch∆∞a
        if (message.deletedBy && message.deletedBy.some(id => id.toString() === userId)) {
          socket.emit("delete_message_error", { error: "Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c b·∫°n x√≥a tr∆∞·ªõc ƒë√≥" });
          return;
        }
        
        // Th√™m userId v√†o m·∫£ng deletedBy
        if (!message.deletedBy) {
          message.deletedBy = [];
        }
        
        message.deletedBy.push(userId);
        await message.save();
        
        // Ch·ªâ g·ª≠i th√¥ng b√°o cho ng∆∞·ªùi d√πng ƒëang th·ª±c hi·ªán thao t√°c
        // kh√¥ng ph√°t s√≥ng cho t·∫•t c·∫£ m·ªçi ng∆∞·ªùi trong cu·ªôc tr√≤ chuy·ªán
        socket.emit("message_deleted", { messageId, conversationId, forUser: userId });
      } catch (error) {
        console.error("Error deleting message via socket:", error);
        socket.emit("delete_message_error", { error: "Kh√¥ng th·ªÉ x√≥a tin nh·∫Øn" });
      }
    });

    socket.on("create_conversation", async (data) => {
      try {
        const { userFrom, userTo } = data;
        const newConversation = await createConversation(userFrom, userTo);
        io.to(userFrom).to(userTo).emit("new_conversation", newConversation);
      } catch (error) {
        console.error("Error creating conversation:", error);
        socket.emit("conversation_error", { message: "Kh√¥ng th·ªÉ t·∫°o cu·ªôc tr√≤ chuy·ªán" });
      }
    });

    socket.on("leave_conversation", (idConversation) => {
      socket.leave(idConversation);
      io.to(idConversation).emit("user_left", socket.id);
    });

    socket.on("typing", (data) => {
      const { idConversation, userId } = data;
      socket.to(idConversation).emit("user_typing", userId);
    });

    socket.on("stop_typing", (data) => {
      const { idConversation, userId } = data;
      socket.to(idConversation).emit("user_stop_typing", userId);
    });

    // X·ª≠ l√Ω th√™m c·∫£m x√∫c v√†o tin nh·∫Øn
    socket.on("add_reaction", async (data) => {
      try {
        const { messageId, conversationId, userId, emoji } = data;
        
        // T√¨m tin nh·∫Øn
        const message = await MessageModel.findById(messageId);
        
        if (!message) {
          socket.emit("reaction_error", { error: "Kh√¥ng t√¨m th·∫•y tin nh·∫Øn" });
          return;
        }

        // Kh·ªüi t·∫°o reactions object n·∫øu ch∆∞a c√≥
        if (!message.reactions) {
          message.reactions = {};
        }
        
        // Kh·ªüi t·∫°o m·∫£ng ng∆∞·ªùi d√πng cho emoji n√†y n·∫øu ch∆∞a c√≥
        if (!message.reactions[emoji]) {
          message.reactions[emoji] = [];
        }
        
        // Th√™m userId v√†o danh s√°ch n·∫øu ch∆∞a c√≥
        if (!message.reactions[emoji].includes(userId)) {
          message.reactions[emoji].push(userId);
          await message.save();
          
          console.log(`üëç Ng∆∞·ªùi d√πng ${userId} ƒë√£ th√™m c·∫£m x√∫c ${emoji} v√†o tin nh·∫Øn ${messageId}`);
        }
        
        // G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ ng∆∞·ªùi d√πng trong cu·ªôc tr√≤ chuy·ªán
        io.to(conversationId).emit("message_reaction", { 
          messageId, 
          emoji,
          userId,
          action: 'add'
        });
      } catch (error) {
        console.error("Error adding reaction:", error);
        socket.emit("reaction_error", { error: "Kh√¥ng th·ªÉ th√™m c·∫£m x√∫c" });
      }
    });
    
    // X·ª≠ l√Ω x√≥a c·∫£m x√∫c kh·ªèi tin nh·∫Øn
    socket.on("remove_reaction", async (data) => {
      try {
        const { messageId, conversationId, userId, emoji } = data;
        
        // T√¨m tin nh·∫Øn
        const message = await MessageModel.findById(messageId);
        
        if (!message) {
          socket.emit("reaction_error", { error: "Kh√¥ng t√¨m th·∫•y tin nh·∫Øn" });
          return;
        }
        
        // Ki·ªÉm tra xem c√≥ reactions kh√¥ng
        if (message.reactions && message.reactions[emoji]) {
          // X√≥a userId kh·ªèi danh s√°ch
          message.reactions[emoji] = message.reactions[emoji].filter(id => id.toString() !== userId);
          
          // N·∫øu kh√¥ng c√≤n ai th·∫£ emoji n√†y, x√≥a kh·ªèi danh s√°ch
          if (message.reactions[emoji].length === 0) {
            delete message.reactions[emoji];
          }
          
          await message.save();
          console.log(`üëé Ng∆∞·ªùi d√πng ${userId} ƒë√£ x√≥a c·∫£m x√∫c ${emoji} kh·ªèi tin nh·∫Øn ${messageId}`);
        }
        
        // G·ª≠i th√¥ng b√°o cho t·∫•t c·∫£ ng∆∞·ªùi d√πng trong cu·ªôc tr√≤ chuy·ªán
        io.to(conversationId).emit("message_reaction", { 
          messageId, 
          emoji,
          userId,
          action: 'remove'
        });
      } catch (error) {
        console.error("Error removing reaction:", error);
        socket.emit("reaction_error", { error: "Kh√¥ng th·ªÉ x√≥a c·∫£m x√∫c" });
      }
    });

    // X·ª≠ l√Ω chuy·ªÉn ti·∫øp tin nh·∫Øn
    socket.on("forward_message", async (data) => {
      try {
        const { messageId, conversationId, userId } = data;
        
        // T√¨m tin nh·∫Øn g·ªëc v√† populate th√¥ng tin ng∆∞·ªùi g·ª≠i
        const originalMessage = await MessageModel.findById(messageId).populate('sender', 'name avatar');
        
        if (!originalMessage) {
          socket.emit("forward_message_error", { error: "Kh√¥ng t√¨m th·∫•y tin nh·∫Øn" });
          return;
        }

        // T·∫°o tin nh·∫Øn m·ªõi v·ªõi n·ªôi dung ƒë∆∞·ª£c chuy·ªÉn ti·∫øp
        const forwardedMessage = new MessageModel({
          idConversation: conversationId,
          content: originalMessage.content,
          type: originalMessage.type,
          seen: false,
          sender: userId,
          fileUrl: originalMessage.fileUrl,
          fileName: originalMessage.fileName,
          fileType: originalMessage.fileType,
          isForwarded: true,
          originalMessage: originalMessage._id,
          forwardedBy: userId,
          originalSender: originalMessage.sender._id,
          originalSenderName: originalMessage.sender.name,
          originalSenderAvatar: originalMessage.sender.avatar
        });

        const savedMessage = await forwardedMessage.save();
        
        // C·∫≠p nh·∫≠t tin nh·∫Øn cu·ªëi c√πng cho cu·ªôc tr√≤ chuy·ªán
        await updateLastMesssage({ 
          idConversation: conversationId, 
          message: savedMessage._id 
        });

        // Populate th√¥ng tin ng∆∞·ªùi g·ª≠i ƒë·ªÉ tr·∫£ v·ªÅ ƒë·∫ßy ƒë·ªß th√¥ng tin
        const populatedMessage = await MessageModel.findById(savedMessage._id)
          .populate('sender', 'name avatar')
          .populate('originalSender', 'name avatar');

        // CH·ªà g·ª≠i tin nh·∫Øn t·ªõi ph√≤ng cu·ªôc tr√≤ chuy·ªán ƒë√≠ch
        io.to(conversationId).emit("new_message", populatedMessage);
        
        // Th√¥ng b√°o th√†nh c√¥ng cho ng∆∞·ªùi g·ª≠i - ch·ªâ g·ª≠i cho client g·ªçi socket
        socket.emit("forward_message_success", populatedMessage);
        
      } catch (error) {
        console.error("Error forwarding message:", error);
        socket.emit("forward_message_error", { error: "Kh√¥ng th·ªÉ chuy·ªÉn ti·∫øp tin nh·∫Øn" });
      }
    });
    
    socket.on("disconnect", () => {
      console.log(`${socket.id} disconnected`);
    });
  });
};

// H√†m ti·ªán √≠ch ƒë·ªÉ g·ª≠i tin nh·∫Øn m·ªõi ƒë·∫øn c√°c client trong cu·ªôc tr√≤ chuy·ªán
export const emitNewMessage = async (message, socketId = null) => {
  if (ioInstance && message && message.idConversation) {
    console.log(`üîî Emitting new message to conversation ${message.idConversation}`);
    
    // Ensure message is in the right format
    let formattedMessage = message;
    
    // If message is a Mongoose document, convert to plain object
    if (message.toObject && typeof message.toObject === 'function') {
      formattedMessage = message.toObject();
    }
    
    // Log detailed info for file messages
    if (formattedMessage.type !== 'text') {
      console.log(`üì® Emitting ${formattedMessage.type} message:`, {
        id: formattedMessage._id,
        type: formattedMessage.type,
        fileUrl: formattedMessage.fileUrl,
        fileName: formattedMessage.fileName,
        fileType: formattedMessage.fileType,
        content: formattedMessage.content
      });
      
      // ƒê·∫£m b·∫£o c√°c thu·ªôc t√≠nh file ƒë∆∞·ª£c gi·ªØ l·∫°i
      if (!formattedMessage.fileUrl) {
        console.warn('‚ö†Ô∏è Message is missing fileUrl! This will cause rendering issues.');
      }
      if (!formattedMessage.fileName && (formattedMessage.type !== 'text' && formattedMessage.type !== 'image')) {
        console.warn('‚ö†Ô∏è Non-text/image message is missing fileName! This will cause rendering issues.');
      }
    }
    
    // If a specific socketId is provided, emit to all clients in the conversation except the sender
    if (socketId) {
      console.log(`üì≤ Detected socketId: ${socketId}, direct emit`);
      ioInstance.to(formattedMessage.idConversation.toString()).except(socketId).emit('new_message', formattedMessage);
    } else {
      // Otherwise, emit to all clients in the conversation
      ioInstance.to(formattedMessage.idConversation.toString()).emit('new_message', formattedMessage);
    }
    return true;
  }
  return false;
};

// Xu·∫•t ioInstance ƒë·ªÉ c√°c module kh√°c c√≥ th·ªÉ s·ª≠ d·ª•ng
export const getIO = () => ioInstance;
